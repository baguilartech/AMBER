# GitLab CI/CD Pipeline for Amber Discord Bot
# Based on Auto-DevOps template with customizations

image: 
  name: sonarsource/sonar-scanner-cli:11
  entrypoint: [""]

stages:
  - build
  - lint
  - test
  - deploy
  - review
  - dast
  - staging
  - canary
  - production
  - incremental rollout 10%
  - incremental rollout 25%
  - incremental rollout 50%
  - incremental rollout 100%
  - performance
  - cleanup

variables:
  NODE_VERSION: "20"
  npm_config_cache: "$CI_PROJECT_DIR/.npm"
  SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"  # Defines the location of the analysis task cache
  GIT_DEPTH: "0"  # Tells git to fetch all the branches of the project, required by the analysis task
  # Docker TLS configuration for all jobs that need Docker
  DOCKER_TLS_CERTDIR: "/certs"
  DOCKER_HOST: tcp://docker:2376
  DOCKER_TLS_VERIFY: 1
  DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
  DOCKER_DRIVER: overlay2

# Cache template
.cache_template: &cache_template
  cache:
    key: 
      files:
        - package-lock.json
    paths:
      - node_modules/
      - .npm/
    policy: pull

.cache_push_template: &cache_push_template
  cache:
    key: 
      files:
        - package-lock.json
    paths:
      - node_modules/
      - .npm/
    policy: pull-push

# Docker TLS template
.docker_tls_template: &docker_tls_template
  services:
    - name: docker:26.1.4-dind
      alias: docker
      command: ["--tls=true", "--tlsverify=false", "--host=tcp://0.0.0.0:2376"]
  variables:
    # Use TLS but without client verification to simplify connectivity
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_VERIFY: 0  # Disable client cert verification for now
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
    DOCKER_DRIVER: overlay2
    # Add timeout settings
    DOCKER_CLI_TIMEOUT: 300
    COMPOSE_HTTP_TIMEOUT: 300

# Common Docker TLS setup script
.docker_tls_setup: &docker_tls_setup |
  # Install required tools
  apk add --no-cache wget ca-certificates curl netcat-openbsd
  
  # Download and install CA certificate (if CA_CERT_URL is provided)
  if [ -n "$CA_CERT_URL" ]; then
    echo "Downloading CA certificate from $CA_CERT_URL..."
    wget -q -O /usr/local/share/ca-certificates/custom-ca.crt "$CA_CERT_URL" || curl -k -o /usr/local/share/ca-certificates/custom-ca.crt "$CA_CERT_URL"
    update-ca-certificates
    
    # Also add the CA certificate to Docker's certificate directory for the registry
    mkdir -p "/etc/docker/certs.d/${CI_REGISTRY}"
    cp /usr/local/share/ca-certificates/custom-ca.crt "/etc/docker/certs.d/${CI_REGISTRY}/ca.crt"
    echo "CA certificate configured for registry: $CI_REGISTRY"
  else
    echo "No CA_CERT_URL provided, skipping custom CA certificate setup"
  fi
  
  # Debug Docker setup
  echo "Docker configuration:"
  echo "DOCKER_HOST: $DOCKER_HOST"
  echo "DOCKER_TLS_VERIFY: $DOCKER_TLS_VERIFY"
  echo "DOCKER_CERT_PATH: $DOCKER_CERT_PATH"
  echo "DOCKER_TLS_CERTDIR: $DOCKER_TLS_CERTDIR"
  
  # Wait for Docker daemon to be ready
  echo "Waiting for Docker daemon to start..."
  timeout=120
  while [ $timeout -gt 0 ]; do
    # Try to connect to Docker daemon
    if docker version >/dev/null 2>&1; then
      echo "Docker daemon is responding"
      break
    fi
    # Also try basic connectivity test
    if nc -z docker 2376 2>/dev/null; then
      echo "Docker port 2376 is reachable"
      # Try Docker command again
      if docker version >/dev/null 2>&1; then
        echo "Docker daemon is responding after port check"
        break
      fi
    fi
    echo "Waiting for Docker daemon... ($timeout seconds remaining)"
    sleep 5
    timeout=$((timeout - 5))
  done
  
  if [ $timeout -le 0 ]; then
    echo "Docker daemon failed to start within timeout"
    echo "Attempting diagnosis..."
    echo "Network connectivity test:"
    nc -z docker 2376 && echo "Port 2376 is reachable" || echo "Port 2376 is not reachable"
    nc -z docker 2375 && echo "Port 2375 is reachable" || echo "Port 2375 is not reachable"
    echo "Docker command output:"
    docker version 2>&1 || echo "Docker command failed"
    exit 1
  fi
  
  # Verify Docker is working
  echo "Testing Docker connection..."
  docker version
  echo "Docker connection successful!"

# Build stage
build:
  stage: build
  image: node:20
  <<: *cache_push_template
  before_script:
    - apt-get update && apt-get install -y python3 make g++
    - npm ci --cache .npm --prefer-offline
  script:
    - npm run build
  artifacts:
    paths:
      - dist/
      - node_modules/
    expire_in: 1 hour
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
    - if: $CI_COMMIT_BRANCH == 'master'
    - if: $CI_COMMIT_BRANCH == 'main'
    - if: $CI_COMMIT_BRANCH == 'develop'

# Lint job
lint:
  stage: lint
  image: node:20
  services: []  # Override Auto-DevOps services
  needs:
    - job: build
      artifacts: true
  dependencies:
    - build
  before_script:
    - ls -la node_modules/.bin/ || echo "node_modules/.bin not found"
    - npm list @typescript-eslint/eslint-plugin || echo "TypeScript ESLint plugin not found"
    - npm list @typescript-eslint/parser || echo "TypeScript ESLint parser not found"
    - npm list eslint || echo "ESLint not found"
    - echo "ESLint version $(npx eslint --version)"
    - echo "TypeScript ESLint plugin version $(npm list @typescript-eslint/eslint-plugin)"
    - echo "TypeScript ESLint parser version $(npm list @typescript-eslint/parser)"
    - echo "Current working directory $(pwd)"
    - echo "ESLint config file exists $(test -f .eslintrc.json && echo 'Yes' || echo 'No')"
    - cat .eslintrc.json || echo "Could not read .eslintrc.json"
  script:
    - echo "Testing ESLint configuration..."
    - npx eslint --print-config src/index.ts > /dev/null || echo "ESLint config test failed"
    - echo "Running linting..."
    - npm run lint
  artifacts:
    reports:
      junit: reports/lint-results.xml
    when: always
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
    - if: $CI_COMMIT_BRANCH == 'master'
    - if: $CI_COMMIT_BRANCH == 'main'
    - if: $CI_COMMIT_BRANCH == 'develop'

# Security scanning
security_scan:
  stage: lint
  image: node:20
  services: []  # Override Auto-DevOps services
  needs:
    - job: build
      artifacts: true
  dependencies:
    - build
  script:
    - echo "Running security audit..."
    - npm audit || echo "Security vulnerabilities found - please review and fix"
    - echo "Audit report generated"
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
    - if: $CI_COMMIT_BRANCH == 'master'
    - if: $CI_COMMIT_BRANCH == 'main'
    - if: $CI_COMMIT_BRANCH == 'develop'

# Build Docker Image
build_docker:
  stage: test  # Move to test stage so it runs after lint
  image: docker:26.1.4
  <<: *docker_tls_template
  needs:
    - job: build
      artifacts: true
    - job: lint  # Wait for linting to pass before building Docker image
  dependencies:
    - build
  before_script:
    - *docker_tls_setup
    - |
      # Login to Docker registry
      echo "Logging into Docker registry: $CI_REGISTRY"
      echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker build -t $CI_REGISTRY_IMAGE:latest .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE:latest
  rules:
    - if: $CI_COMMIT_BRANCH == 'main'
    - if: $CI_COMMIT_BRANCH == 'develop'
    - if: $CI_COMMIT_TAG

# Override code_quality job from Auto-DevOps to fix Docker TLS issues
code_quality:
  stage: test
  image: docker:26.1.4  # Use same version as build_docker for consistency
  <<: *docker_tls_template
  before_script:
    - *docker_tls_setup
    - |
      # Additional setup for code quality tools if needed
      echo "Docker TLS setup completed successfully"
      docker version
      docker info
  script:
    - |
      # Code quality analysis would go here
      # For now, just test Docker connectivity
      echo "Testing Docker connectivity with TLS..."
      docker info
      echo "Code quality analysis placeholder - Docker is working!"
  allow_failure: true  # Allow failure since this is still being configured
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
    - if: $CI_COMMIT_BRANCH == 'master'
    - if: $CI_COMMIT_BRANCH == 'main'
    - if: $CI_COMMIT_BRANCH == 'develop'

# SAST (Static Application Security Testing)
sast:
  stage: test

# SonarQube Analysis
sonar_scan:
  stage: test
  image: sonarsource/sonar-scanner-cli:11
  needs:
    - job: build
      artifacts: true
    - job: lint  # Wait for linting to complete
    - job: test
      artifacts: true
  dependencies:
    - build
    - test
  cache:
    policy: pull-push
    key: "sonar-cache-$CI_COMMIT_REF_SLUG"
    paths:
      - "${SONAR_USER_HOME}/cache"
      - sonar-scanner/
  before_script:
    - |
      # Check if SONAR_HOST_URL is set and valid
      if [ -z "$SONAR_HOST_URL" ]; then
        echo "SONAR_HOST_URL is not set. Skipping SonarQube analysis."
        exit 0
      fi
      # Add scheme if missing
      if [[ ! "$SONAR_HOST_URL" =~ ^https?:// ]]; then
        echo "Adding http:// scheme to SONAR_HOST_URL"
        export SONAR_HOST_URL="http://${SONAR_HOST_URL}"
      fi
      echo "SonarQube URL: $SONAR_HOST_URL"
  script: 
    - sonar-scanner -Dsonar.host.url="${SONAR_HOST_URL}"
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
    - if: $CI_COMMIT_BRANCH == 'master'
    - if: $CI_COMMIT_BRANCH == 'main'
    - if: $CI_COMMIT_BRANCH == 'develop'

# Test stage
test:
  stage: test
  image: node:20
  services: []  # Override Auto-DevOps services
  needs:
    - job: build
      artifacts: true
    - job: lint  # Wait for linting to pass before running tests
  dependencies:
    - build
  before_script:
    - ls -la  # Debug: check if artifacts are present
    - ls -la node_modules/ || echo "node_modules not found"
    - which jest || echo "jest not found in PATH"
    - npm list jest || echo "jest not in npm list"
  script:
    - npm run test:ci
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    when: always
    reports:
      junit: junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
    paths:
      - coverage/
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
    - if: $CI_COMMIT_BRANCH == 'master'
    - if: $CI_COMMIT_BRANCH == 'main'
    - if: $CI_COMMIT_BRANCH == 'develop'
    
# Deploy to staging
# deploy_staging:
#   stage: staging
#   image: alpine:latest
#   before_script:
#     - apk add --no-cache curl
#   script:
#     - |
#       echo "Deploy to staging environment"
#       echo "Image: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA"
#   environment:
#     name: staging
#     url: https://staging.your-domain.com
#   dependencies:
#     - build_docker
#   rules:
#     - if: $CI_COMMIT_BRANCH == 'develop'
#       when: manual

# Deploy to production
# deploy_production:
#   stage: production
#   image: alpine:latest
#   before_script:
#     - apk add --no-cache curl
#   script:
#     - |
#       echo "Deploy to production environment"
#       echo "Image: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA"
#   environment:
#     name: production
#     url: https://your-domain.com
#   dependencies:
#     - build_docker
#   rules:
#     - if: $CI_COMMIT_BRANCH == 'main'
#       when: manual
#     - if: $CI_COMMIT_TAG
#       when: manual

# Pages for coverage reports
pages:
  stage: deploy
  dependencies:
    - test
  script:
    - mkdir public
    - cp -r coverage/lcov-report/* public/
  artifacts:
    paths:
      - public
    expire_in: 30 days
  rules:
    - if: $CI_COMMIT_BRANCH == 'main'

# Include Auto-DevOps template
include:
  - template: Auto-DevOps.gitlab-ci.yml

# Override staging job from Auto-DevOps to disable it
staging:
  rules:
    - when: never

# Override canary job from Auto-DevOps to disable it
canary:
  rules:
    - when: never

# Override production job from Auto-DevOps to disable it
production:
  rules:
    - when: never